<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BINGO BONGO</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: #1e1e1e;
            transition: background 0.3s ease;
        }
        
        body.light-mode {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .theme-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #3e3e42;
            border: 1px solid #555555;
            color: #d4d4d4;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.15s ease;
            z-index: 1000;
        }
        
        .theme-toggle:hover {
            background: #505050;
        }
        
        body.light-mode .theme-toggle {
            background: white;
            color: #333;
            border: 1px solid #ddd;
        }
        
        body.light-mode .theme-toggle:hover {
            background: #f5f5f5;
        }
        
        .container {
            background: #252526;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            border: 1px solid #3e3e42;
            transition: all 0.3s ease;
            position: relative;
        }
        
        body.light-mode .container {
            background: white;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            border: none;
        }
        
        h1 {
            text-align: center;
            color: #4ec9b0;
            margin: 0 0 20px 0;
            font-weight: 600;
            letter-spacing: 1px;
            transition: color 0.3s ease;
        }
        
        body.light-mode h1 {
            color: #333;
        }
        
        .status {
            text-align: center;
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 20px;
            color: #d4d4d4;
            transition: color 0.3s ease;
        }
        
        body.light-mode .status {
            color: #555;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .tile {
            width: 60px;
            height: 60px;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            background: #2d2d30;
            cursor: pointer;
            font-size: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            color: #d4d4d4;
        }
        
        body.light-mode .tile {
            border: 1px solid #ddd;
            background: #f5f5f5;
            color: #333;
        }
        
        .tile:hover:not(.flipped) {
            background: #37373d;
            border-color: #007acc;
        }
        
        body.light-mode .tile:hover:not(.flipped) {
            border-color: #999;
            background: #e8e8e8;
        }
        
        .tile.flipped {
            background: #4ec9b0;
            border-color: #4ec9b0;
            color: #1e1e1e;
        }
        
        body.light-mode .tile.flipped {
            background: #4caf50;
            border-color: #45a049;
            color: white;
        }
        
        .tile.suggest-1 {
            background: #4fc3f7;
            border-color: #4fc3f7;
            color: #1e1e1e;
            box-shadow: 0 0 15px rgba(79, 195, 247, 0.6);
        }
        
        body.light-mode .tile.suggest-1 {
            background: #FFD700;
            border-color: #DAA520;
            color: #000;
            box-shadow: none;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .strategy-toggle {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            color: #d4d4d4;
            font-size: 14px;
        }
        
        body.light-mode .strategy-toggle {
            color: #555;
        }
        
        .strategy-toggle label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        
        .strategy-toggle input[type="checkbox"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        
        .strategy-description {
            font-size: 12px;
            color: #888;
            text-align: center;
            max-width: 300px;
            line-height: 1.4;
        }
        
        body.light-mode .strategy-description {
            color: #666;
        }
        
        .info-button {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 32px;
            height: 32px;
            background: #3e3e42;
            border: 1px solid #555555;
            color: #d4d4d4;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }
        
        .info-button:hover {
            background: #505050;
            transform: scale(1.1);
        }
        
        body.light-mode .info-button {
            background: white;
            color: #333;
            border: 1px solid #ddd;
        }
        
        body.light-mode .info-button:hover {
            background: #f5f5f5;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: #252526;
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            border: 1px solid #3e3e42;
            position: relative;
            color: #d4d4d4;
            line-height: 1.6;
        }
        
        body.light-mode .modal-content {
            background: white;
            color: #333;
            border: none;
        }
        
        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #d4d4d4;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .modal-close:hover {
            background: #3e3e42;
            transform: none;
        }
        
        body.light-mode .modal-close {
            color: #333;
        }
        
        body.light-mode .modal-close:hover {
            background: #f0f0f0;
        }
        
        .modal-content h2 {
            color: #4ec9b0;
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        body.light-mode .modal-content h2 {
            color: #667eea;
        }
        
        .modal-content p {
            margin: 10px 0;
        }
        
        .modal-content strong {
            color: #4ec9b0;
        }
        
        body.light-mode .modal-content strong {
            color: #667eea;
        }
        
        button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.15s ease;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        button:hover {
            transform: translateY(-1px);
        }
        
        .suggest-btn {
            background: #007acc;
            color: #ffffff;
        }
        
        body.light-mode .suggest-btn {
            background: #88f;
            color: white;
        }
        
        .suggest-btn:hover {
            background: #0098ff;
        }
        
        .suggest-btn {
            background: #007acc;
            color: #ffffff;
        }
        
        body.light-mode .suggest-btn {
            background: #88f;
            color: white;
        }
        
        .suggest-btn:hover {
            background: #0098ff;
        }
        
        .reset-btn {
            background: #3e3e42;
            color: #d4d4d4;
            border: 1px solid #555555;
        }
        
        body.light-mode .reset-btn {
            background: #f88;
            color: white;
            border: none;
        }
        
        .reset-btn:hover {
            background: #505050;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="toggleTheme()">‚òÄÔ∏è Light Mode</button>
    
    <div class="modal" id="infoModal" onclick="closeModalOnBackdrop(event)">
        <div class="modal-content">
            <button class="modal-close" onclick="toggleModal()">√ó</button>
            <h2>Strategy Guide</h2>
            <p><strong>Aggressive Strategy:</strong> Best when the 4th reward is particularly valuable (like 5 gold tears or other rare items). This strategy maximizes your chance of completing 4 lines (~26%) but has a higher risk of ending with only 2 lines (~5%).</p>
            <p><strong>Balanced Strategy:</strong> Recommended for most situations. This strategy prioritizes consistent 3-line completions while still taking opportunistic shots at 4 lines. It significantly reduces the risk of 2-line outcomes.</p>
            <p><strong>Pro Tip:</strong> Check your 4th reward before each round. If it's something you really want, switch to aggressive. Otherwise, play it safe with the balanced strategy for more reliable rewards.</p>
        </div>
    </div>
    
    <div class="container">
        <button class="info-button" onclick="toggleModal()">i</button>
        <h1>BINGO BONGO</h1>
        <div class="status" id="status">Flips used: 0 / 16</div>
        <div class="grid" id="grid"></div>
        <div class="controls">
            <div class="strategy-toggle">
                <label>
                    <input type="checkbox" id="strategyToggle" onchange="toggleStrategy()">
                    <span>Balanced Strategy (prioritize consistent 3-line wins)</span>
                </label>
                <div class="strategy-description" id="strategyDesc">
                    Current: Aggressive 4-line strategy (~26% 4-line, ~69% 3-line, ~5% 2-line)
                </div>
            </div>
            <button class="reset-btn" onclick="resetBoard()">Reset Board</button>
        </div>
    </div>

    <script>
        const GRID_SIZE = 5;
        const MAX_FLIPS = 16;
        
        class Line {
            constructor() {
                this.cells = [];
            }
            
            get isComplete() {
                return this.cells.every(cell => cell.used);
            }
        }
        
        class Cell {
            constructor(id, field, row, column) {
                this.id = id;
                this.field = field;
                this.row = row;
                this.column = column;
                this.used = false;
                this.lines = [row, column];
                this.diagonals = [];
            }
            
            getLineCompletionDesc() {
                const counts = [];
                for (const line of this.lines) {
                    let lineCount = 0;
                    for (const cell of line.cells) {
                        if (cell.used) lineCount++;
                    }
                    counts.push(lineCount);
                }
                return counts.sort((a, b) => b - a);
            }
        }
        
        class Field {
            constructor(size = 5) {
                this.size = size;
                this.rows = [];
                this.columns = [];
                this.diagonals = [new Line(), new Line()];
                this.cells = [];
                
                for (let i = 0; i < size; i++) {
                    const row = new Line();
                    this.rows.push(row);
                    
                    for (let j = 0; j < size; j++) {
                        if (i === 0) {
                            this.columns.push(new Line());
                        }
                        
                        const column = this.columns[j];
                        const cell = new Cell(i * size + j + 1, this, row, column);
                        row.cells.push(cell);
                        column.cells.push(cell);
                        this.cells.push(cell);
                        
                        if (i === j) {
                            this.diagonals[0].cells.push(cell);
                            cell.lines.push(this.diagonals[0]);
                            cell.diagonals.push(this.diagonals[0]);
                        }
                        
                        if (i + j + 1 === size) {
                            this.diagonals[1].cells.push(cell);
                            cell.lines.push(this.diagonals[1]);
                            cell.diagonals.push(this.diagonals[1]);
                        }
                    }
                }
                
                this.lines = [...this.columns, ...this.rows, ...this.diagonals];
            }
            
            get linesCompleted() {
                return this.lines.filter(line => line.isComplete).length;
            }
            
            reset() {
                this.cells.forEach(cell => cell.used = false);
            }
            
            finishable(targetPattern, maxMoves) {
                let movesNeeded = 0;
                for (let i = 0; i < this.cells.length; i++) {
                    if (targetPattern.cells[i].used && !this.cells[i].used) {
                        movesNeeded++;
                        if (movesNeeded > maxMoves) return false;
                    }
                }
                return true;
            }
            
            clone() {
                const clone = new Field(this.size);
                for (let i = 0; i < this.cells.length; i++) {
                    clone.cells[i].used = this.cells[i].used;
                }
                return clone;
            }
        }
        
        function createPatterns(targetLines = 4, maxMoves = 16, field = new Field(), line = 1, index = 0, indices = [], patterns = {}) {
            for (; index < field.lines.length - targetLines + line; index++) {
                indices.push(index);
                
                if (line === targetLines) {
                    for (const lineIndex of indices) {
                        for (let cellIndex = 0; cellIndex < field.lines[lineIndex].cells.length; cellIndex++) {
                            field.lines[lineIndex].cells[cellIndex].used = true;
                        }
                    }
                    
                    let moves = field.cells.filter(cell => cell.used).length;
                    
                    if (moves <= maxMoves) {
                        if (!patterns[moves]) patterns[moves] = [];
                        patterns[moves].push(field.clone());
                    }
                    
                    field.reset();
                } else {
                    createPatterns(targetLines, maxMoves, field, line + 1, index + 1, indices, patterns);
                }
                
                indices.pop();
            }
            
            return patterns;
        }
        
        function getMostCompleteCell(cells) {
            let bestCell = null;
            let bestCounts = [];
            
            for (const cell of cells) {
                if (cell.used) continue;
                
                const counts = cell.getLineCompletionDesc();
                
                for (let i = 0; i < counts.length || i < bestCounts.length; i++) {
                    if (bestCounts[i] === undefined || counts[i] > bestCounts[i]) {
                        bestCounts = counts;
                        bestCell = cell;
                        break;
                    } else if (counts[i] === undefined || counts[i] < bestCounts[i]) {
                        break;
                    }
                }
            }
            
            return bestCell;
        }
        
        function createHeatmap(patterns) {
            const heatmap = Array(patterns[0].cells.length).fill(0);
            
            for (const pattern of patterns) {
                for (let i = 0; i < pattern.cells.length; i++) {
                    if (pattern.cells[i].used) {
                        heatmap[i]++;
                    }
                }
            }
            
            return heatmap;
        }
        
        function getHeatMapOfBestPatterns(field, remainingMoves) {
            let patterns = [];
            
            for (const patternLib of currentPatternLibs) {
                patterns = patternLib.patterns.filter(pattern => 
                    field.finishable(pattern, remainingMoves - patternLib.remainingMovesOffset)
                );
                
                if (patterns.length > 0) break;
            }
            
            if (patterns.length === 0) return null;
            
            return createHeatmap(patterns);
        }
        
        function getHottestCell(field, remainingMoves) {
            const heatmap = getHeatMapOfBestPatterns(field, remainingMoves);
            
            if (!heatmap) {
                return getMostCompleteCell(field.cells);
            }
            
            let baseCells = field.cells;
            let hotCells = [];
            
            do {
                let maxHeat = Number.NEGATIVE_INFINITY;
                
                for (const cell of baseCells) {
                    if (cell.used) continue;
                    
                    const heat = heatmap[cell.id - 1];
                    
                    if (heat > maxHeat) {
                        maxHeat = heat;
                        hotCells = [cell];
                    } else if (heat === maxHeat) {
                        hotCells.push(cell);
                    }
                }
                
                if (hotCells.length === 1) break;
                
                remainingMoves--;
                const nextHeatmap = getHeatMapOfBestPatterns(field, remainingMoves);
                
                if (!nextHeatmap || remainingMoves === 1) break;
                
                baseCells = hotCells;
                hotCells = [];
            } while (true);
            
            return getMostCompleteCell(hotCells);
        }
        
        const fourLinePatterns = createPatterns(4);
        const allFourLinePatterns = [].concat(...Object.values(fourLinePatterns));
        
        const threeLinePatterns = createPatterns(3);
        const allThreeLinePatterns = [].concat(...Object.values(threeLinePatterns));
        
        const allTwoLinePatterns = [].concat(...Object.values(createPatterns(2)));
        
        const aggressivePatternLibs = [
            { lines: 4, patterns: allFourLinePatterns, remainingMovesOffset: 2 },
            { lines: 4, patterns: allFourLinePatterns, remainingMovesOffset: 1 },
            { lines: 4, patterns: allFourLinePatterns, remainingMovesOffset: 0 },
            { lines: 3, patterns: allThreeLinePatterns, remainingMovesOffset: 1 },
            { lines: 3, patterns: allThreeLinePatterns, remainingMovesOffset: 0 },
            { lines: 2, patterns: allTwoLinePatterns, remainingMovesOffset: 1 },
            { lines: 2, patterns: allTwoLinePatterns, remainingMovesOffset: 0 },
        ];
        
        const balancedPatternLibs = [
            { lines: 3, patterns: allThreeLinePatterns, remainingMovesOffset: 2 },
            { lines: 3, patterns: allThreeLinePatterns, remainingMovesOffset: 1 },
            { lines: 4, patterns: allFourLinePatterns, remainingMovesOffset: 1 },
            { lines: 3, patterns: allThreeLinePatterns, remainingMovesOffset: 0 },
            { lines: 4, patterns: allFourLinePatterns, remainingMovesOffset: 0 },
            { lines: 2, patterns: allTwoLinePatterns, remainingMovesOffset: 1 },
            { lines: 2, patterns: allTwoLinePatterns, remainingMovesOffset: 0 },
        ];
        
        let currentPatternLibs = aggressivePatternLibs;
        
        const field = new Field();
        let tiles = {};
        let turnFlips = 0;
        
        function toggleModal() {
            const modal = document.getElementById('infoModal');
            modal.classList.toggle('active');
        }
        
        function closeModalOnBackdrop(event) {
            if (event.target.id === 'infoModal') {
                toggleModal();
            }
        }
        
        function initGrid() {
            const grid = document.getElementById('grid');
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.onclick = () => toggleTile(r, c);
                    grid.appendChild(tile);
                    tiles[`${r},${c}`] = tile;
                }
            }
        }
        
        function toggleTile(r, c) {
            const cellId = r * GRID_SIZE + c;
            const cell = field.cells[cellId];
            
            if (cell.used) {
                cell.used = false;
                tiles[`${r},${c}`].className = 'tile';
                turnFlips--;
            } else {
                if (turnFlips >= MAX_FLIPS) return;
                cell.used = true;
                tiles[`${r},${c}`].className = 'tile flipped';
                turnFlips++;
            }
            
            clearHighlights();
            updateStatus();
            
            if (turnFlips < MAX_FLIPS && turnFlips % 2 === 0) {
                suggestMove();
            }
        }
        
        function resetBoard() {
            field.reset();
            for (let key in tiles) {
                tiles[key].className = 'tile';
            }
            turnFlips = 0;
            updateStatus();
            suggestMove();
        }
        
        function updateStatus() {
            document.getElementById('status').textContent = `Flips used: ${turnFlips} / ${MAX_FLIPS}`;
        }
        
        function suggestMove() {
            if (turnFlips >= MAX_FLIPS) return;
            
            const chosenFlipsUsed = Math.floor(turnFlips / 2);
            const attemptsLeft = 8 - chosenFlipsUsed;
            
            const bestCell = getHottestCell(field, attemptsLeft);
            
            if (bestCell) {
                const r = Math.floor((bestCell.id - 1) / GRID_SIZE);
                const c = (bestCell.id - 1) % GRID_SIZE;
                highlightSuggestion(r, c);
            }
        }
        
        function clearHighlights() {
            for (let key in tiles) {
                const [r, c] = key.split(',').map(Number);
                const cellId = r * GRID_SIZE + c;
                if (!field.cells[cellId].used) {
                    tiles[key].className = 'tile';
                }
            }
        }
        
        function highlightSuggestion(r, c) {
            clearHighlights();
            const cellId = r * GRID_SIZE + c;
            if (!field.cells[cellId].used) {
                tiles[`${r},${c}`].classList.add('suggest-1');
            }
        }
        
        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            const btn = document.querySelector('.theme-toggle');
            if (document.body.classList.contains('light-mode')) {
                btn.textContent = 'üåô Dark Mode';
            } else {
                btn.textContent = '‚òÄÔ∏è Light Mode';
            }
        }
        
        function toggleStrategy() {
            const checkbox = document.getElementById('strategyToggle');
            const desc = document.getElementById('strategyDesc');
            
            if (checkbox.checked) {
                currentPatternLibs = balancedPatternLibs;
                desc.textContent = 'Current: Balanced 3-line strategy (prioritizes consistent 3-line wins, opportunistic 4-lines)';
            } else {
                currentPatternLibs = aggressivePatternLibs;
                desc.textContent = 'Current: Aggressive 4-line strategy (~26% 4-line, ~69% 3-line, ~5% 2-line)';
            }
            
            if (turnFlips > 0 && turnFlips < MAX_FLIPS && turnFlips % 2 === 0) {
                clearHighlights();
                suggestMove();
            }
        }
        
        initGrid();
        suggestMove();
    </script>
</body>
</html>
